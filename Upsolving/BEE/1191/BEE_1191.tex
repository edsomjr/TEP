%\section{BEE 1191 -- Recuperação da Árvore}

\begin{frame}[fragile]{Problema}

A pequena Valentina gostava muito de brincar com árvores binárias. Seu jogo favorito era construir árvores binárias aleatórias com letras em maiúsculo nos nodos.

Este é um exemplo de uma de suas criações:
 
\begin{verbatim}
                                        D
                                       / \
                                      /   \
                                     B     E
                                    / \     \
                                   /   \     \
                                  A     C     G
                                             /
                                            /
                                           F
\end{verbatim}
\end{frame}
 

\begin{frame}[fragile]{Problema}
Para salvar suas árvores para uso futuro, ela escreveu duas strings para cada árvore: o percurso prefixo (raíz, sub-árvore esquerda, sub-árvore direita) e o percurso infixo (sub-árvore esquerda, raíz, sub-árvore direita).

Para o desenho acima o percurso prefixo é DBACEGF e o infixo é ABCDEFG.

Agora, anos depois, olhando para as strings, ela notou que reconstruir as árvores era realmente possível, mas só porque ela não havia usado a mesma letra duas vezes na mesma árvore.

Reconstruir a árvore a mão tornou-se chato.

Então agora ela pede que você escreva um programa que faça o trabalho por ela!

\end{frame}

\begin{frame}[fragile]{Entrada e saída}

\textbf{Entrada}

A entrada irá conter um ou mais casos de teste. Cada caso de teste consiste em uma linha contendo duas strings representando o percurso prefixo e infixo de uma árvore binária. Ambas as strings consistem de letras maiúsculas, sem repetir. (Então elas não são maiores de 26 caracteres.)

Entrada termina com EOF (fim de arquivo).

\vspace{0.2in}

\textbf{Saída}

Para cada caso de teste, imprima uma linha com o percurso posfixo (sub-árvore esquerda, sub-árvore direita, raíz).

\end{frame}


\begin{frame}[fragile]{Exemplo de entradas e saídas}

\begin{minipage}[t]{0.5\textwidth}
\textbf{Exemplo de Entrada}
\begin{verbatim}
DBACEGF ABCDEFG
BCAD CBAD
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\textbf{Exemplo de Saída}
\begin{verbatim}
ACBFGED
CDAB
\end{verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N^2)$}

    \begin{itemize}
        \item É necessário implementar o método construtor e a rotina de inserção 

        \item A reconstrução da árvore parte de dois fatos importantes

        \item O primeiro deles é que a travessia em-ordem estabelece uma ordenação que permite
            a comparação entre os valores das informações a serem inseridas na árvore

        \item Esta ordenação deve ser utilizada na inserção, substituíndo a ordenação lexicográfica
            padrão imposta pelo operador \code{c}{<}

        \item A ordem de inserção dos elementos na árvore é determinada pela travessia pré-ordem

        \item Finalizada a inserção, basta imprimir na saída a árvore usando a travessia pós-ordem
   \end{itemize}

\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N^2)$}
    \inputsnippet{cpp}{1}{20}{codes/BEE1191.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N^2)$}
    \inputsnippet{cpp}{22}{38}{codes/BEE1191.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N^2)$}
    \inputsnippet{cpp}{40}{61}{codes/BEE1191.cpp}
\end{frame}
