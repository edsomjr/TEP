\section{Codeforces Round \#179 -- Problem A: Greg and Array}

\begin{frame}[fragile]{Problema}

Greg has an array $a = a_1, a_2, \ldots, a_n$ and $m$ operations. Each operation looks as: 
$l_i, r_i, d_i, (1\leq l_i\leq r_i\leq n)$. To apply operation $i$ to the array means to increase 
all array elements with numbers $l_i, l_i + 1, \ldots, r_i$ by value $d_i$.

Greg wrote down $k$ queries on a piece of paper. Each query has the following form: 
$x_i, y_i, (1\leq x_i\leq y_i\leq m)$. That means that one should apply operations with numbers 
$x_i, x_i + 1, \ldots, y_i$ to the array.

Now Greg is wondering, what the array a will be after all the queries are executed. Help Greg.

\end{frame}

\begin{frame}[fragile]{Entrada e saída}

\textbf{Input}

The first line contains integers $n, m, k (1\leq n, m, k\leq 10^5)$. The second line contains 
$n$ integers: $a_1, a_2, \ldots, a_n (0\leq a_i\leq 10^5)$ -- the initial array.

Next $m$ lines contain operations, the operation number $i$ is written as three integers: 
$l_i, r_i, d_i, (1\leq l_i\leq r_i\leq n), (0\leq d_i\leq 10^5)$.

Next $k$ lines contain the queries, the query number $i$ is written as two integers: 
$x_i, y_i, (1\leq x_i\leq y_i\leq m)$.

The numbers in the lines are separated by single spaces.

\textbf{Output}

On a single line print $n$ integers $a_1, a_2,\ldots, a_n$ -- the array after executing all the queries. Separate the printed numbers by spaces.

Please, do not use the \texttt{\%lld} specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the \texttt{\%I64d} specifier.

\end{frame}

\begin{frame}[fragile]{Exemplo de entradas e saídas}

\begin{minipage}[t]{0.5\textwidth}
\textbf{Sample Input}
\begin{verbatim}
3 3 3
1 2 3
1 2 1
1 3 2
2 3 4
1 2
1 3
2 3

1 1 1
1
1 1 1
1 1
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\textbf{Sample Output}
\begin{verbatim}
9 18 17








2
\end{verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}

    \begin{itemize}
        \item A solução tem três partes

        \item A primeira é acumular o número de vezes que cada operação deverá ser realizada

        \item Isto pode ser feito com uma árvore de Fenwick com suporte para \textit{range update}

        \item Em seguida, deve-se acumular o impacto de cada operação no vetor original

        \item O número de vezes $x$ que a operação $i$ será aplicada pode ser feita com uma
            \textit{point query} na árvore

        \item Novamente é necessária uma árvore de Fenwick com suporte para \textit{range update}

        \item O intervalo $[L, R]$ deve ser atualizado com o valor $dx$

        \item Por fim, a cada posição do vetor $i$ deve ser adicionado o valor $y$ obtido
            pela \textit{point query} do índice $i$ da árvore
   \end{itemize}

\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{1}{21}{codes/295A.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{22}{41}{codes/295A.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{42}{62}{codes/295A.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{63}{83}{codes/295A.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{84}{104}{codes/295A.cpp}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(N + (M + K)\log (M + K))$}
    \inputsnippet{cpp}{105}{125}{codes/295A.cpp}
\end{frame}
