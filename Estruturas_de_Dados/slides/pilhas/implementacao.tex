\section{Implementação}

\begin{frame}[fragile]{Implementação de uma pilha}

    \begin{itemize}
        \item Como uma pilha é um tipo de dados abstrato, ela não impõe nenhuma restrição
            quanto à sua implementação

        \item É possível implementar uma pilha por composição, usando listas encadeadas ou vetores

        \item A estratégia LIFO pode ser implementada fazendo-se a inserção e a remoção em uma
            mesma ponta da lista, de modo que uma lista simplesmente encadeada é suficiente

        \item Basta utilizar as operações \code{c}{push_front()} e \code{c}{pop_front()}, 
            respectivamente, uma vez que ambas tem complexidade $O(1)$

        \item Utilizar vetores reduz a quantidade de memória necessária, porém as operações passam
            a ter complexidade $O(1)$ amortizada, devido às ocasionais realocações do vetor para
            ampliar sua capacidade máxima

        \item Se há uma estimativa do número máximo de elementos na pilha, estas realocações
            podem ser evitadas (ou minimizadas), resultando em uma implementação bastante
            eficiente
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Implementação de uma pilha em C++}
    \inputsnippet{c++}{4}{22}{codes/stack.h}
\end{frame}

\begin{frame}[fragile]{Implementação de uma pilha em C++}
    \inputsnippet{c++}{1}{21}{codes/main.cpp}
\end{frame}

\begin{frame}[fragile]{Implementação de uma pilha em C++}
    \inputsnippet{c++}{22}{42}{codes/main.cpp}
\end{frame}

\begin{frame}[fragile]{Pilhas em C++}

    \begin{itemize}
        \item A biblioteca padrão de templates (STL) do C++ provê o contêiner \code{c}{stack},
            que implementa uma pilha

        \item Tanto o tipo de dado a ser armazenado quando o contêiner que será usado na composição
            são parametrizáveis

        \item Por padrão, o contêiner utilizado é um \code{c}{deque} (\textit{double-ended queue}),
            mas os contêineres \code{c}{vector} e \code{c}{list} são igualmente válidos

        \item O contêiner escolhido deve ter, em sua interface, os métodos \code{cpp}{push_back()}
            e \code{cpp}{pop_back()}

        \item A interface é idêntica à apresentada anteriormente, exceto pela adição do método
            \code{c}{swap()}, que troca os elementos de duas pilhas em $O(1)$, e pela exclusão
            do método \code{c}{clear()}

    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exemplo de uso da classe stack da STL}
    \inputsnippet{c++}{1}{17}{codes/stl.cpp}
\end{frame}

\begin{frame}[fragile]{Exemplo de uso da classe stack da STL}
    \inputsnippet{c++}{18}{38}{codes/stl.cpp}
\end{frame}
